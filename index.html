<!DOCTYPE html>
<html lang="en">
<!-- Pop-Up Box! -->
<!-- Bugged: Line color setting. Shift-clicking and dragging same box multiple times deselects it. Dragging highlights boxes' text.Lines 'jump' after resizing. -->
<!-- Working: Create boxes, move boxes, connect boxes, delete boxes. Make boxes bold, italic, underline, or struck thorough. Box resizing & box/line styling. Saving/loading from cookie. -->
<!-- Todo: Clarify box vs container. Clean code. Reduce use of getElementById. Undo button. Make canvas bigger and scrollable. Print. -->

<head>
    <title>Pop-Up Box</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <style>
        #canvas {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: gray;
            cursor: crosshair;  /* crosshair barely visible on laptop*/
        }

        .box {
            background-color: white;
            border: 2px solid black;
            border-radius: 4px;
            box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.3);
            outline: none;
            position: absolute;
            width: 200px;
            height: 50px;
            z-index: 1;
            font-weight: normal;
            font-style: normal;
            text-decoration: none;
            /* make resizable */
            resize: both;
            overflow: hidden;
            text-overflow: ellipsis;
            display: inline-block;
            /* no extra spaces */
            margin: 0;
            white-space: nowrap;
            min-width: 3em;
        }

        .box.start {
            outline: 3px solid #d2796a !important;
        }

        .box:focus {
            border: blue !important;
        }

        /* let <input> assume the size of the wrapper. necessary? */
        .box > input {
            border: 0;
            width: 100%;
            height: 100%;
            display: inline-block;
            z-index: 2;
            font-size: 14px;
        }

        /* add a visible handle. necessary? */
        .box > span {
            display: inline-block;
            vertical-align: bottom;
            margin-left: -16px;
            width: 16px;
            height: 16px;
            background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAJUlEQVR4AcXJRwEAIBAAIPuXxgiOW3xZYzi1Q3Nqh+bUDk1yD9sQaUG/4ehuEAAAAABJRU5ErkJggg==");
            /*cursor: ew-resize;*/
        }

        .box.selected {
            outline: 3px solid #7db1e8;
            z-index: 10;
        }

        .line.selected {
            filter: drop-shadow(1px 1px 0px #7db1e8) drop-shadow(-1px 1px 0px #7db1e8) drop-shadow(1px -1px 0px #7db1e8) drop-shadow(-1px -1px 0px #7db1e8);
        }

        .line {
            stroke: black;
            stroke-width: 2px;
            stroke-dasharray: none;
        }

        .top-bar {
            background-color: lightgray;
            color: black;
            padding: 4px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 999;
            border-bottom: 3px solid black;
            box-shadow: 0 4px 10px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: flex-end;
            /* Align buttons to the right */
        }

        .top-bar button {
            width: 40px;
            height: 40px;
            border: 2px solid black;
            background-color: transparent;
            box-shadow: 0 8px 16px 0 rgba(0, 0, 0, 0.2);
            margin-left: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .top-bar button:hover {
            background-color: #919191;
            box-shadow: 0 0 5px 2px rgba(100, 100, 100, 0.8) inset;
        }

        .top-bar .icon-button img {
            width: 24px;
            height: 24px;
            pointer-events: none;
        }

        .separator {
            width: 1px;
            background-color: #676767; /* Light gray line */
            height: 40px; /* Adjust the height as needed */
            margin: 0 2px 0 7px; /* Space on either side of the separator */
        }

        .no-max-width {
            max-width: none !important;
            width: 300px !important;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 55px;
            max-width: 70px;
            overflow: hidden;
            box-shadow: 0 8px 16px 0 rgba(0, 0, 0, 0.2);
            z-index: 1;
            right: 0;
            left: unset;
            transform-origin: top right;
            top: 100%;
            /* Adjust the top based on the top bar */
        }

        .dropdown.show .dropdown-content {
            display: block;
            left: unset;
            right: 0;
            top: 100%;
            transform-origin: bottom right;
            /* Change top position to appear below the button */
        }

        .dropdown-content a {
            color: black;
            padding: 6px 6px;
            text-decoration: none;
            display: block;
        }

        .dropdown-content a:hover {
            background-color: #E0E0E0;
            outline: 1px solid black;
        }

        #colorDropdownContainer {
            width: 0;
        }

        table {
            background-color: lightgray;
            border: black solid 2px;
            border-collapse: collapse;
            z-index: 9999;
            position: absolute;
            box-shadow: 0 4px 10px 0 rgba(0, 0, 0, 0.2);
        }

        td {
            border: 1px solid gray;
            width: 30px;
            height: 30px;
            text-align: center;
            box-sizing: border-box; /* Include padding and border in the total width and height */
            z-index: 9999;
            position: relative;
        }

        .colorButton button {
            width: 100%;
            height: 100%;
            box-sizing: border-box; /* Include padding and border in the total width and height */
            z-index: 9999;
        }

        a > input {
            /* All input children of a (dropdowns) */
            size: 20px;
            width: 100%;
        }

        .show {
            display: block;
        }

        .bold {
            font-weight: bold;
        }

        .italic {
            font-style: italic;
        }

        .underline {
            text-decoration: underline;
        }

        .strikethrough {
            text-decoration: line-through;
        }

        .underline-strikethrough {
            text-decoration: underline line-through;
        }

        #selection-rectangle {
            position: absolute;
            border: 2px dashed #000;
            background-color: rgba(0, 0, 0, 0.2);
            pointer-events: none;
            display: none; /* Initially hide the rectangle */
            z-index: 100;
        }

        @media print {
            .no-print {
                display: none;
            }

            .box {
                outline: none !important;
            }

            body,
            html {
                width: 100vw;
            }

            @page {
                size: landscape
            }
        }
    </style>
</head>

<body>
<div class="top-bar no-print" id='top-bar'>
    <button class="icon-button" onclick="showColorDropdown(event, [canvas], 'background')" title="Canvas Color">
        <img src="images/background-fill.svg" alt="Canvas Color">
    </button>

    <div class="separator"></div>

    <button class="icon-button" onclick="showColorDropdown(event, selectedBoxes, 'background')" title="Box Color">
        <img src="images/box-fill.svg" alt="Box Color">
    </button>

    <div class="separator"></div>

    <button class="icon-button" onclick="showColorDropdown(event, selectedBoxes, 'border')" title="Border Color">
        <img src="images/border-color.svg" alt="Border Color">
    </button>

    <div class="dropdown" data-dropdown="widthDropdown">
        <button class="icon-button dropbtn" onclick="toggleDropdown(this)" title="Border Width">
            <img src="images/box-outline.svg" alt="Border Width">
        </button>
        <div class="dropdown-content">
            <a href="#" onclick="changeWidth('1px', 'border')" data-style="1px">1 px</a>
            <a href="#" onclick="changeWidth('2px', 'border')" data-style="2px">2 px</a>
            <a href="#" onclick="changeWidth('3px', 'border')" data-style="3px">3 px</a>
            <a href="#" onclick="changeWidth('4px', 'border')" data-style="4px">4 px</a>
            <a href="#" onclick="changeWidth('5px', 'border')" data-style="5px">5 px</a>
            <a href="#" onclick="changeWidth('6px', 'border')" data-style="6px">6 px</a>
            <a href="#" onclick="changeWidth('8px', 'border')" data-style="8px">8 px</a>
            <a href="#" onclick="changeWidth('10px', 'border')" data-style="10px">10 px</a>
        </div>
    </div>

    <div class="dropdown" data-dropdown="styleDropdown">
        <button class="icon-button dropbtn" onclick="toggleDropdown(this)" title="Border Style">
            <img src="images/border-style.svg" alt="Border Style">
        </button>
        <div class="dropdown-content">
            <a href="#" onclick="changeStyle('solid', 'border')" data-style="solid">Solid</a>
            <a href="#" onclick="changeStyle('dashed', 'border')" data-style="dashed">Dashed</a>
            <a href="#" onclick="changeStyle('dotted', 'border')" data-style="dotted">Dotted</a>
            <a href="#" onclick="changeStyle('none', 'border')" data-style="none">None</a>
        </div>
    </div>

    <div class="separator"></div>

    <button class="icon-button" onclick="showColorDropdown(event, selectedLines, 'color')" title="Line Color">
        <img src="images/line-color.svg" alt="Line Color">
    </button>

    <div class="dropdown" data-dropdown="widthDropdown">
        <button class="icon-button dropbtn" onclick="toggleDropdown(this)" title="Line Width">
            <img src="images/line-thickness.svg" alt="Line Width">
        </button>
        <div class="dropdown-content">
            <a href="#" onclick="changeWidth('1px', 'line')" data-style="1px">1 px</a>
            <a href="#" onclick="changeWidth('2px', 'line')" data-style="2px">2 px</a>
            <a href="#" onclick="changeWidth('3px', 'line')" data-style="3px">3 px</a>
            <a href="#" onclick="changeWidth('4px', 'line')" data-style="4px">4 px</a>
            <a href="#" onclick="changeWidth('5px', 'line')" data-style="5px">5 px</a>
            <a href="#" onclick="changeWidth('6px', 'line')" data-style="6px">6 px</a>
            <a href="#" onclick="changeWidth('8px', 'line')" data-style="8px">8 px</a>
            <a href="#" onclick="changeWidth('10px', 'line')" data-style="10px">10 px</a>
        </div>
    </div>

    <div class="dropdown" data-dropdown="styleDropdown">
        <button class="icon-button dropbtn" onclick="toggleDropdown(this)" title="Line Style">
            <img src="images/line-type.svg" alt="Line Style">
        </button>
        <div class="dropdown-content">
            <a href="#" onclick="changeStyle('0', 'line')" data-style="solid">Solid</a>
            <a href="#" onclick="changeStyle('7 5', 'line')" data-style="dashed">Dashed</a>
            <a href="#" onclick="changeStyle('3', 'line')" data-style="dotted">Dotted</a>
        </div>
    </div>

    <div class="separator"></div>

    <button class="icon-button" onclick="showColorDropdown(event, selectedBoxes, 'color')" title="Text Color">
        <img src="images/text-color.svg" alt="Text Color">
    </button>

    <div class="dropdown" data-dropdown="widthDropdown">
        <button class="icon-button dropbtn" onclick="toggleDropdown(this)" title="Text Size">
            <img src="images/text-size.svg" alt="Text Size">
        </button>
        <div class="dropdown-content">
            <a href="#" onclick="changeWidth('8px', 'text')" data-style="8px">8 px</a>
            <a href="#" onclick="changeWidth('12px', 'text')" data-style="12px">12 px</a>
            <a href="#" onclick="changeWidth('14px', 'text')" data-style="14px">14 px</a>
            <a href="#" onclick="changeWidth('16px', 'text')" data-style="16px">16 px</a>
            <a href="#" onclick="changeWidth('18px', 'text')" data-style="18px">18 px</a>
            <a href="#" onclick="changeWidth('20px', 'text')" data-style="20px">20 px</a>
            <a href="#" onclick="changeWidth('30px', 'text')" data-style="30px">30 px</a>
            <a href="#" onclick="changeWidth('40px', 'text')" data-style="40px">40 px</a>
            <a href="#" onclick="changeWidth('60px', 'text')" data-style="60px">60 px</a>
            <a href="#" onclick="event.stopPropagation()" data-style="custom" width="10">Custom
                <label>
                    <input class="custom-width" type="number" data-target="text" id="custom-text-width"/>
                </label>
            </a>
        </div>
    </div>

    <button class="icon-button" onclick="styleText('bold')" title="Bold">
        <img src="images/bold.svg" alt="Bold">
    </button>

    <button class="icon-button" onclick="styleText('italic')" title="Italic">
        <img src="images/italic.svg" alt="Italic">
    </button>

    <button class="icon-button" onclick="styleText('underline')" title="Underline">
        <img src="images/underline.svg" alt="Underline">
    </button>

    <button class="icon-button" onclick="styleText('strikethrough')" title="Strikethrough">
        <img src="images/strikethrough.svg" alt="Strikethrough">
    </button>

    <div class="separator"></div>

    <button class="icon-button" onclick="saveDataLocally()" title="Save">
        <img src="images/save.svg" alt="Save">
    </button>

    <button class="icon-button" onclick="loadDataLocally()" title="Load">
        <img src="images/load.svg" alt="Load">
    </button>

    <button class="icon-button" onclick="downloadData()" title="Download">
        <img src="images/download.svg" alt="Download">
    </button>

    <button class="icon-button" onclick="uploadData()" title="Upload">
        <img src="images/upload.svg" alt="Upload">
    </button>

    <button class="icon-button" onclick="test()" title="Test">
        <img src="images/test.svg" alt="Test">
    </button>

    <div class="dropdown">
        <button class="icon-button dropbtn" onclick="toggleDropdown(this)" title="Usage">
            <img src="images/info.svg" alt="Usage">
        </button>
        <div class="dropdown-content no-max-width">
            <a href="#">Create Box by Clicking the Canvas</a>
            <a href="#">Move Box by Clicking and Dragging</a>
            <a href="#">Connect Boxes by Ctrl-Clicking Them</a>
            <a href="#">Delete Box by Alt-Clicking</a>
            <a href="#">Resize Box by Clicking and Dragging Bottom Right Corner</a>
            <a href="#">Select Box by Clicking, Shift+Click to Multiselect</a>
            <a href="#">Select All Boxes with Ctrl+A</a>
            <a href="#">Deselect All Boxes with Ctrl+D</a>
            <a href="#">Move All Selected Boxes by Shift-Clicking and Dragging</a>
            <a href="#">Delete All Selected Boxes with Alt+Backspace</a>
            <a href="#">Delete everything with Ctrl+Delete</a>
            <a href="#">Select Lines By Clicking and Dragging</a>
            <a href="#">Change Canvas, Box, and Line Styles with Top Bar Buttons</a>
            <a href="#">Ctrl+B for Bold, Ctrl+I for Italics, Ctrl+U for Underline, and Ctrl+5 for Strikethrough</a>

        </div>
    </div>

</div>

<div id="selection-rectangle"></div>
<div id="colorDropdownContainer"></div>

<div class="container">
    <div id="canvas" style="height: 100vh;"></div>
    <svg id="lineContainer"
         style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></svg>
    <svg id="selContainer"
         style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></svg>
</div>

<script>
    let boxCount = 0;
    let selectedBoxes = [];
    let selectedLines = [];
    let lineStartBox = null;
    let lines = []; // unlike selBoxes, store info not element cuz must create new ele w/ that info
    const lineSvg = document.getElementById("lineContainer");
    const canvas = document.getElementById('canvas');
    let customColors = [null, null, null, null, null, null, null, null, null, null];

    function setUpCustomInputs() {
        const colorInputs = document.querySelectorAll(".custom-color");
        colorInputs.forEach((input) => {
            input.addEventListener("input", setCustomColor, false);
            input.addEventListener("change", setCustomColor, false);
            input.addEventListener('keydown', function onEvent(event) {
                if (event.key === "Enter") {
                    closeDropdowns();
                }
            });
            input.select();
        });
        const widthInputs = document.querySelectorAll(".custom-width");
        widthInputs.forEach((input) => {
            input.addEventListener("input", setCustomWidth, false);
            input.addEventListener('keydown', function onEvent(event) {
                if (event.key === "Enter") {
                    closeDropdowns();
                    input.value = '';
                }
            });
        });
    }

    function addBox(event) {
        const target = event.target;
        if (target.classList.contains("box")) {
            return;
        } else if (event.altKey) {
            deselectBoxes();
            return;
        }
        const xPos = event.clientX;
        const yPos = event.clientY;
        const boxWidth = 150;
        const boxHeight = 40;
        const box = document.createElement("input");
        const boxContainer = document.createElement("span");
        const boxLeft = xPos - boxWidth / 2 + "px";
        const boxTop = yPos - boxHeight / 2 + "px";
        // Set up boxContainer properties
        boxContainer.id = "containerBox" + boxCount;
        box.placeholder = "Type here";
        boxContainer.style.left = boxLeft;
        boxContainer.style.top = boxTop;
        boxContainer.style.width = boxWidth + "px";
        boxContainer.style.height = boxHeight + "px";
        boxContainer.style.outlineWidth = boxContainer.style.borderWidth = "2px";
        // Add event listeners to boxContainer
        boxContainer.addEventListener("mousedown", startDrag);
        boxContainer.addEventListener("click", handleBoxSelection);
        // Set up box properties
        box.id = "box" + boxCount;
        box.style.padding = "0px 5px";
        // Set box type attribute
        box.setAttribute("type", "text");
        // Add classes to both box and boxContainer
        box.classList.add("box");
        box.classList.add("box-input");
        boxContainer.classList.add("box");
        // why get by Id here? changed
        canvas.appendChild(boxContainer);
        boxContainer.appendChild(box);
        box.focus();
        if (!event.shiftKey) {
            deselectBoxes();
        }
        selectBox(box);
        console.log("made " + box.id);
        boxCount++;
    }

    function selectBox(target, removeExisting = false) {
        let box = getContainerFromId(target.id);
        if (!selectedBoxes.includes(target)) { // only add if not alr in
            box.classList.add("selected");
            selectedBoxes.push(target);
        } else if (removeExisting) {
            selectedBoxes.splice(selectedBoxes.indexOf(target), 1);
            box.classList.remove("selected");
        }
    }

    function handleBoxSelection(event) { //too big
        const target = event.target;
        if (!target.classList.contains("icon-button") && !event.shiftKey) {
            deselectBoxes();
        }
        const box = getContainerFromId(target.id);
        if (box) {
            if (event.altKey) {  // Delete box
                const boxId = box.id;
                deleteBox(boxId);
                deleteLines(boxId);
                console.log("removing box " + boxId);
                return;
            }
            if (!event.ctrlKey) {  // Just select box
                selectBox(event.target, true);
                let selectedBoxIds = []; // to log selected boxes
                selectedBoxes.forEach((b) => {
                    if (b) {
                        selectedBoxIds.push(b.id);
                    }
                    console.log("Selected Boxes:" + selectedBoxIds);
                });
                return;
            }  // connect box
            selectBox(event.target);
            if (!lineStartBox) { // handle line creation
                lineStartBox = box;
                box.classList.add("start");
            } else {
                const startBoxId = lineStartBox.id; // Get the Id of the start box
                const endBoxId = box.id; // Get the Id of the end box
                const lineId = "line" + lines.length; // Unique Id for the line
                lineStartBox.classList.remove("start");
                let newLineData = {
                    lineId: lineId,
                    startBox: startBoxId,
                    endBox: endBoxId,
                    lineColor: "black",
                    lineWidth: "2px",
                    lineDash: "none"
                };
                lines.push(newLineData); // Store line data //in object
                createLine(newLineData);
                lineStartBox = null;
            }
        } else {
            updateLines();
        }
    }

    function deselectBoxes() {
        selectedBoxes.forEach((b) => {
            let box = getContainerFromId(b.id);
            if (box) {
                box.classList.remove("selected");
            }
        });
        selectedLines.forEach((line) => {
            if (line) {
                line.classList.remove("selected");
            }
        });
        selectedBoxes = [];
        selectedLines = [];
        console.log("Deselected boxes/lines");
    }

    function getId(boxId) {
        // starting from end, get all numbers, reverse them, and return them
        let Id = '';
        for (let i = boxId.length - 1; i >= 0; i--) {
            let c = boxId[i];
            if (c >= '0' && c <= '9') {
                Id += c;
            } else {
                Id = Id.split("").reverse().join("");
                return Id;
            }
        }
    }

    function getContainerFromId(boxId) {
        return document.getElementById("containerBox" + getId(boxId));
    }

    function getBoxFromId(boxId) {
        return document.getElementById("box" + getId(boxId));
    }

    function startDrag(event) {
        if (!event.shiftKey && !event.ctrlKey && !event.altKey) { //was breaking connecting w/o
            handleBoxSelection(event); //means must hold shift to drag multiple, but wont automatically drag all boxes too
        }
        const target = event.target;
        const boxContainer = getContainerFromId(target.id);
        if (!boxContainer) return; // Ensure we're dragging a valid box

        let isResizing = false;
        let initialX, initialY, initialWidth, initialHeight, allInitialX, allInitialY;

        // Check if the mouse is near the resize handle (bottom-right corner)
        const boxRect = boxContainer.getBoundingClientRect();
        const resizeAreaThreshold = 18; // proximity to corner to trigger resizing

        // If mouse is near the bottom-right corner, trigger resizing
        if (event.clientX > boxRect.right - resizeAreaThreshold && event.clientY > boxRect.bottom - resizeAreaThreshold) {
            isResizing = true;
            initialWidth = boxContainer.offsetWidth;
            initialHeight = boxContainer.offsetHeight;
            initialX = event.clientX;
            initialY = event.clientY;
        } else {
            // Otherwise, it's moving the box
            target.style.cursor = 'grabbing';
            boxContainer.style.cursor = 'grabbing'; // not rly sure both needed
            allInitialX = [];
            allInitialY = [];
            initialX = event.clientX - target.getBoundingClientRect().left + 2;
            initialY = event.clientY - target.getBoundingClientRect().top + 2;
            boxContainer.style.zIndex = "999"; // Bring the dragged box to the front
            selectedBoxes.forEach((b) => {
                let bContainer = getContainerFromId(b.id);
                allInitialX.push(event.clientX - bContainer.getBoundingClientRect().left);
                allInitialY.push(event.clientY - bContainer.getBoundingClientRect().top);
            });
        }

        boxContainer.style.zIndex = "999"; // Bring the dragged box to the front

        function moveBox(event) {
            if (isResizing) {
                // Resize the box based on mouse movement
                const deltaX = event.clientX - initialX;
                const deltaY = event.clientY - initialY;
                boxContainer.style.width = initialWidth + deltaX + 'px';
                boxContainer.style.height = initialHeight + deltaY + 'px';
            } else {
                // const newX = event.clientX - initialX + parseInt(boxContainer.style.borderWidth) + parseInt(boxContainer.style.outlineWidth);
                // const newY = event.clientY - initialY + parseInt(boxContainer.style.borderWidth) + parseInt(boxContainer.style.outlineWidth);
                const newX = event.clientX - initialX;
                const newY = event.clientY - initialY;
                boxContainer.style.left = newX + "px";
                boxContainer.style.top = newY + "px";
                console.log("newX: " + newX + " newY: " + newY);
                for (let i = 0; i < selectedBoxes.length; i++) {
                    let thisBox = getContainerFromId(selectedBoxes[i].id);
                    // let newBoxX = event.clientX - allInitialX[i] - parseInt(thisBox.style.borderWidth);
                    // let newBoxY = event.clientY - allInitialY[i] - parseInt(thisBox.style.borderWidth);
                    let newBoxX = event.clientX - allInitialX[i];
                    let newBoxY = event.clientY - allInitialY[i];
                    thisBox.style.left = newBoxX + "px";
                    thisBox.style.top = newBoxY + "px";
                }
            }
            updateLines(); // Update lines during dragging/resizing
        }

        function stopDrag() {
            target.style.cursor = '';
            boxContainer.style.cursor = '';
            document.removeEventListener("mousemove", moveBox);
            document.removeEventListener("mouseup", stopDrag);
            // selectedBoxes.forEach((b) => {
            //     let bContainer = getContainerFromId(b.id);
            boxContainer.style.zIndex = ""; // Restore the original z-index. Needed or above dropdowns
            // });
            updateLines(); // Update the lines after dragging stops
            let r =boxContainer.getBoundingClientRect();
                        console.log(r.left + r.width / 2);
        }

        document.addEventListener("mousemove", moveBox);
        document.addEventListener("mouseup", stopDrag);
    }


    function deleteBox(boxId) {
        // remove box with given Id
        const box = document.getElementById(boxId);
        if (box) {
            box.remove();
            console.log("removed box " + boxId);
        }
    }

    function deleteLines(boxId) {
        // remove all lines connected to the box with given Id
        const allLines = lineSvg.getElementsByClassName("line");
        for (let i = allLines.length - 1; i >= 0; i--) { // Iterate over the lines and remove the ones connected to the box
            const line = allLines[i];
            const startBoxId = line.getAttribute("data-start-box");
            const endBoxId = line.getAttribute("data-end-box");
            if (startBoxId === boxId || endBoxId === boxId) {
                lines = lines.filter(l => l.lineId !== line.id);
                line.remove(); // remove from array too? It doesn't. prob shouldn't unless all deleted. actually should else nonexistant lines get saved
            }
        }
    }

    function createLine(lineInfo) { //(lineId, startBoxId, endBoxId) {
        const startBox = document.getElementById(lineInfo.startBox);
        const endBox = document.getElementById(lineInfo.endBox);
        if (startBox && endBox) {
            const start = getCenter(startBox);
            const end = getCenter(endBox);
            let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.classList.add("line");
            line.setAttribute("id", lineInfo.lineId);
            line.setAttribute("x1", start.x);
            line.setAttribute("y1", start.y);
            line.setAttribute("x2", end.x);
            line.setAttribute("y2", end.y);
            line.setAttribute("style", "stroke: " + lineInfo.lineColor + ";" +
                "stroke-width: " + lineInfo.lineWidth + ";" +
                "stroke-dasharray: " + lineInfo.lineDash + ";"
            );
            line.setAttribute("data-start-box", lineInfo.startBox);
            line.setAttribute("data-end-box", lineInfo.endBox);
            line.addEventListener("click", handleBoxSelection); // Add click event listener to the line
            lineSvg.appendChild(line);
        }
    }

    function updateLines() { //after moving boxes, rerender lines one by one
        lineSvg.innerHTML = ""; // Clear all existing lines
        lines.forEach((line) => {
            createLine(line);
            //line.createLine(); if OOP
            //lineEle.setAttribute("fill", line.lineColor);
        });
    }


    function getCenter(element) { //get center of box to render lines
        const rect = element.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;
        return {x, y};
    }

    function styleText(style) { //Add style to box text.
        const target = selectedBoxes;
        if (target.length > 0) {
            for (let i = 0; i < target.length; i++) {
                applyTextStyle(getBoxFromId(target[i].id, true).id, style);
            }
        }
    }

    function isStyleApplied(elementId, style) {
        //Check if style is applied. Used by styleText() through applyTextStyle()
        const element = document.getElementById(elementId);
        if (style == "underline" || style == "strikethrough") { // underline-strikethrough counts for both
            return element.classList.contains("underline-strikethrough") || element.classList.contains(style);
        }
        return element.classList.contains(style);
    }

    function applyTextStyle(elementId, style) { //Toggle style. Used by styleText()
        const element = document.getElementById(elementId);
        if (!isStyleApplied(elementId, style)) {
            if (style == "underline" && isStyleApplied(elementId, "strikethrough")) {
                element.classList.remove("strikethrough");
                element.classList.add("underline-strikethrough");
            } else if (style == "strikethrough" && isStyleApplied(elementId, "underline")) {
                element.classList.remove("underline");
                element.classList.add("underline-strikethrough");
            } else {
                element.classList.add(style);
            }
        } else {
            if (style == "underline" && isStyleApplied(elementId, "underline-strikethrough")) {
                element.classList.remove("underline-strikethrough");
                element.classList.add("strikethrough");
            } else if (style == "strikethrough" && isStyleApplied(elementId, "underline-strikethrough")) {
                element.classList.remove("underline-strikethrough");
                element.classList.add("underline");
            } else {
                element.classList.remove(style);
            }
        }
    }

    function changeColor(color, target, targetAttr) {
        // change color using color string, target list, and the target attribute
        if (targetAttr == "background") { // Change the background color of each target element
            target.forEach((element) => {
                element.style.backgroundColor = color;
                getBoxFromId(element.id, true).style.backgroundColor = color;
            });
        } else if (targetAttr == "color") { // Change the font/line color of each target element
            target.forEach((element) => {
                element.style.color = color;
                getBoxFromId(element.id, true).style.color = color;
                if (target === 'selectedLines') { //stroke instead for line
                    selectedLines.forEach((line) => {
                        line.style.stroke = color;
                        const lineId = line.id;
                        const lineInfo = lines.find(l => l.lineId === lineId); //does this work? yup
                        lineInfo['lineColor'] = color;
                    })
                }
            });
        } else if (targetAttr == "border") { // Change the border color of each target element
            target.forEach((element) => {
                let box = getContainerFromId(element.id);
                box.style.borderColor = color;
            });
        }
    }

    function changeWidth(width, target) { //check if works. seems like it!
        if (target == "line") { // Change the width of each target line
            selectedLines.forEach((element) => {
                element.style.strokeWidth = width;
                const lineId = element.id;
                const lineInfo = lines.find(l => l.lineId === lineId); //does this work? yup
                lineInfo['lineWidth'] = width;
            });
        } else if (target == "border") { // Change the border width of each target box
            selectedBoxes.forEach((element) => {
                let box = getContainerFromId(element.id);
                box.style.borderWidth = width;
                updateLines();
            });
        } else if (target == "text") { // Change the size of each target box's text
            selectedBoxes.forEach((element) => {
                let box = getBoxFromId(element.id, true);
                box.style.fontSize = width;
            });
        }
    }

    function changeStyle(style, target) { //check if works. Seems working!
        if (target == "line") { // Change the style of each target line
            selectedLines.forEach((element) => {
                element.style.strokeDasharray = style;
                const lineId = element.id;
                const lineInfo = lines.find(l => l.lineId === lineId); //does this work? yup
                lineInfo['lineDash'] = style;
            });
        } else if (target == "border") { // Change the border style of each target box
            selectedBoxes.forEach((element) => {
                let box = getContainerFromId(element.id);
                box.style.borderStyle = style;
            });
        }
    }

    function toggleDropdown(e) {
        // TODO: hide dropdown when clicked again
        let isShown = e.parentNode.getElementsByClassName("dropdown-content")[0].classList.contains("show");
        closeDropdowns();
        if (!isShown) {
            e.parentNode.getElementsByClassName("dropdown-content")[0].classList.toggle("show");
        }
    }

    function closeDropdowns() {
        let dropdowns = document.getElementsByClassName("dropdown-content");
        for (let i = 0; i < dropdowns.length; i++) {
            let openDropdown = dropdowns[i];
            if (openDropdown.classList.contains('show')) {
                openDropdown.classList.remove('show');
            }
        }
    }

    function setCustomColor(e) { //see if this works. Appears to!
        const color = e.target.value;
        let target = e.target.dataset.target;
        if (target == "boxes") {
            target = selectedBoxes;
        } else if (target == "lines") {
            target = selectedLines;
        } else if (target == "canvas") {
            target = [canvas];
        }
        const attribute = e.target.dataset.attribute;
        changeColor(color, target, attribute);
    }

    function setCustomWidth(e) { //see if this works. seeeems liker!
        const width = e.target.value + "px";
        let target = e.target.dataset.target;
        changeWidth(width, target);
    }

    function selectAll() {
        selectedBoxes = [...document.querySelectorAll(".box-input")];
        selectedBoxes.forEach((b) => {
            getContainerFromId(b.id).classList.add("selected");
        });
    }

    function deleteSelection() {
        selectedBoxes.forEach((box) => {
            deleteLines(getContainerFromId(box.id).id);
            deleteBox(getContainerFromId(box.id).id);
        });
    }

    function deleteAll() {
        selectAll();
        deleteSelection();
        lines = [];
        boxCount = 1;
    }

    function onKeypress(e) {
        if (e.ctrlKey && e.key === 'u') {
            e.preventDefault();
            styleText("underline");
        } else if (e.ctrlKey && e.key === 'b') {
            e.preventDefault();
            styleText("bold");
        } else if (e.ctrlKey && e.key === 'i') {
            e.preventDefault();
            styleText("italic");
        } else if ((e.ctrlKey && e.key === '5') || (e.altKey && e.shiftKey && e.key === '5')) {
            e.preventDefault();
            styleText("strikethrough");
        } else if (e.ctrlKey && e.key === 'a') {
            e.preventDefault();
            selectAll();
            console.log("selected all");
        } else if ((e.ctrlKey && e.key === 'd') || e.key === 'Escape') {
            e.preventDefault();
            deselectBoxes();
            console.log("deselected all");
        } else if (e.altKey && e.key === 'Backspace') {
            e.preventDefault();
            deleteSelection();
            if (!document.querySelector(".box")) {
                boxCount = 0; // reset count only if delete all to prevent too high nums
            }
            if (!document.getElementById(lineStartBox)) {
                lineStartBox = null;
            }
        } else if (e.ctrlKey && e.key === 'Delete') {
            e.preventDefault();
            deleteAll();
        }
    }

    function startSelection(event) {
        // TODO: don't deselect lines if shift key pressed. alter deselectBoxes func?
        if (event.altKey) {
            console.log("desel");
            return;
        }
        if (event.target.classList.contains("box")) {
            return;
        }
        const startXRect = event.pageX;
        const startYRect = event.pageY;
        const threshold = 10; //move into endSel?
        let endXRect = 0;
        let endYRect = 0;
        let isMouseDown = true; // Flag to track mouse down state
        const selectionRectangle = document.getElementById('selection-rectangle');

        function renderSelection(e) {
            if (!isMouseDown) return; // Exit if mouse is not down
            const width = Math.abs(e.pageX - startXRect);
            const height = Math.abs(e.pageY - startYRect);
            const left = Math.min(startXRect, e.pageX);
            const top = Math.min(startYRect, e.pageY);

            selectionRectangle.style.display = 'block'; // Show rectangle
            selectionRectangle.style.width = `${width}px`;
            selectionRectangle.style.height = `${height}px`;
            selectionRectangle.style.left = `${left}px`;
            selectionRectangle.style.top = `${top}px`;
        }

        function pointIsBetween(pointX, pointY, startX, startY, endX, endY) {
            let xBetween = ((pointX > startX && pointX < endX) || (pointX < startX && pointX > endX));
            let yBetween = ((pointY > startY && pointY < endY) || (pointY < startY && pointY > endY));
            return xBetween && yBetween;
        }


        function endSelection(e) {
            isMouseDown = false; // Mouse up, set flag to false
            canvas.removeEventListener("mousemove", renderSelection);
            canvas.removeEventListener("mouseup", endSelection);
            endXRect = e.pageX;
            endYRect = e.pageY;
            selectionRectangle.style.display = 'none'; // Hide rectangle
            if ((Math.abs(startXRect - endXRect) < threshold) && (Math.abs(startYRect - endYRect) < threshold)) {
                addBox(event);
            } else {
                if (!event.shiftKey) {
                    deselectBoxes();
                }
                // select boxes between start and end
                let boxCList = Array.from(canvas.children);
                boxCList.forEach((boxC) => {
                    let boxRect = boxC.getBoundingClientRect();
                    let topLeftBetween = pointIsBetween(boxRect.left, boxRect.top, startXRect, startYRect, endXRect, endYRect);
                    let bottomRightBetween = pointIsBetween(boxRect.right, boxRect.bottom, startXRect, startYRect, endXRect, endYRect);
                    if (topLeftBetween && bottomRightBetween) {
                        selectBox(boxC);
                    }
                })
                lines.forEach((line) => {
                    const lineStart = getCenter(document.getElementById(line.startBox));
                    const lineEnd = getCenter(document.getElementById(line.endBox));
                    const startBetween = pointIsBetween(lineStart.x, lineStart.y, startXRect, startYRect, endXRect, endYRect);
                    const endBetween = pointIsBetween(lineEnd.x, lineEnd.y, startXRect, startYRect, endXRect, endYRect);
                    let lineEle = document.getElementById(line.lineId);
                    if (startBetween && endBetween && lineEle) {
                        selectedLines.push(lineEle);
                        lineEle.classList.add("selected");
                    }
                });
            }
        }

        canvas.addEventListener("mousemove", renderSelection);
        canvas.addEventListener("mouseup", endSelection);
    }


    // Close the dropdown if the user clicks outside of it
    window.onclick = function (event) {
        if (!event.target.matches('.dropbtn')) {
            let dropdowns = document.getElementsByClassName("dropdown-content");
            for (let i = 0; i < dropdowns.length; i++) {
                let openDropdown = dropdowns[i];
                if (openDropdown.classList.contains('show')) {
                    openDropdown.classList.remove('show');
                }
            }
        }
        if (  // close colorDropdown, currently doesn't close on clicking same button
            (!event.target.matches('.top-bar *'))
            && (!event.target.matches('.customColorButton'))
        ) {
            let dropdownContainer = document.getElementById("colorDropdownContainer");
            dropdownContainer.innerHTML = '';
        }
    }

    function saveData() {
        let boxDataList = [];
        let lineDataList = [];
        let i = 0;
        let boxData;
        let boxCList = canvas.childNodes;  // use .children instead?
        boxCList.forEach((boxC) => {  // get box attributes and store in dict
            let Id = boxC.id.split('containerBox').pop();
            let box = document.getElementById('box' + Id);
            boxData = {
                boxId: Id, //boxId is just the number
                boxText: box.value,
                boxLeft: boxC.style.left,
                boxTop: boxC.style.top,
                boxWidth: boxC.style.width,
                boxHeight: boxC.style.height,
                boxColor: boxC.style.backgroundColor,
                boxBorderColor: boxC.style.borderColor,
                boxBorderWidth: boxC.style.borderWidth,
                boxBorderStyle: boxC.style.borderStyle,
                boxTextColor: box.style.color,
                boxTextSize: box.style.fontSize,
                boxClassList: box.classList,
            }
            boxDataList[i] = JSON.stringify(boxData);
            i++;
        })
        // lineList too
        i = 0;
        lines.forEach((line) => {
            lineDataList[i] = JSON.stringify(line);
            i++;
        });
        return {
            boxDict: boxDataList,
            lineDict: lineDataList,
            colorDict: customColors,
            canvasColor: canvas.style.backgroundColor
        }
    }


    function loadData(boxDataList, lineDataList, colorDataList, canvasColor) {
        deleteAll();

        let boxIdMapping = {};
        let newBoxId = boxCount = 1;

        boxDataList.forEach((boxDataString) => {
            if (boxDataString !== '') {
                let boxData = JSON.parse(boxDataString);

                boxIdMapping[boxData.boxId] = newBoxId;
                boxData.boxId = newBoxId;

                recreateBox(boxData);
                boxCount++;
                newBoxId++;
            }
        });

        let i = 0;
        lineDataList.forEach((line) => {
            if (line !== '') {
                line = JSON.parse(line);

                let startBoxId = line.startBox.replace('containerBox', '');
                let endBoxId = line.endBox.replace('containerBox', '');
                line.startBox = 'containerBox' + boxIdMapping[startBoxId];
                line.endBox = 'containerBox' + boxIdMapping[endBoxId];
                lines[i] = line;
                i++;
            }
        });
        updateLines();

        i = 0;
        colorDataList.forEach((color) => {
            if (color === '') {
                customColors[i] = null; // Handle empty colors
            } else {
                customColors[i] = color; // Assign color
            }
            i++;
        });

        canvas.style.backgroundColor = canvasColor;
    }


    function saveDataLocally() {
        let data = saveData();
        localStorage.setItem("boxes", data.boxDict.toString());
        localStorage.setItem("lines", data.lineDict.toString());
        localStorage.setItem("colors", data.colorDict.toString());
        localStorage.setItem("canvasColor", data.canvasColor.toString());
    }

    function loadDataLocally() {
        let boxDataList = localStorage.getItem("boxes").split('}},');
        let lineDataList = localStorage.getItem("lines").split('},');
        let colorDataList = localStorage.getItem("colors").split(",");
        let canvasColor = localStorage.getItem("canvasColor");
        for (let i = 0; i < boxDataList.length - 1; i++) {
            boxDataList[i] = boxDataList[i] + '}}'
        }
        for (let i = 0; i < lineDataList.length - 1; i++) {
            lineDataList[i] = lineDataList[i] + '}'
        }
        loadData(boxDataList, lineDataList, colorDataList, canvasColor);
    }


    function downloadData() {
        let data = saveData();
        let serializedData = JSON.stringify(data);
        let dataURL = "data:text/json;charset=utf-8," + encodeURIComponent(serializedData);
        let link = document.createElement("a");
        link.href = dataURL;
        link.download = "data.json";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function uploadData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.click();
        // Set up an event listener for when a file is selected
        input.addEventListener('change', handleFileSelect);
    }

    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (file && file.type === 'application/json') {
            // Read the content of the file
            const reader = new FileReader();
            reader.onload = function (e) {
                const jsonData = JSON.parse(e.target.result);
                loadData(jsonData.boxDict, jsonData.lineDict, jsonData.colorDict, jsonData.canvasColor);
            };
            reader.readAsText(file);
        } else {
            alert('Please select a valid JSON file.');
        }
    }

    function handleDragOver(event) {
        // Prevent default behavior to enable drop
        event.preventDefault();
    }

    function handleDrop(event) {
        // Prevent default behavior to enable drop
        event.preventDefault();
        const files = event.dataTransfer.files;
        for (const file of files) {
            if (file.type === 'application/json') {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const jsonData = JSON.parse(e.target.result);
                    loadData(jsonData.boxDict, jsonData.lineDict, jsonData.colorDict, jsonData.canvasColor);
                };
                reader.readAsText(file);
            } else {
                console.log('Not a JSON file:', file.name);
            }
        }
    }


    function recreateBox(boxData) {
        let box = document.createElement("input");
        let boxContainer = document.createElement("span");
        boxContainer.id = "containerBox" + boxData.boxId;
        box.placeholder = "Type here";
        boxContainer.style.left = boxData.boxLeft;
        boxContainer.style.top = boxData.boxTop;
        boxContainer.style.width = boxData.boxWidth;
        boxContainer.style.height = boxData.boxHeight;
        box.value = boxData.boxText;
        boxContainer.style.backgroundColor = boxData.boxColor;
        box.style.backgroundColor = boxData.boxColor;
        boxContainer.style.borderColor = boxData.boxBorderColor;
        boxContainer.style.borderWidth = boxData.boxBorderWidth;
        boxContainer.style.borderStyle = boxData.boxBorderStyle;
        boxContainer.style.outlineWidth = "2px";
        box.style.color = boxData.boxTextColor;
        box.style.fontSize = boxData.boxTextSize;
        for (let i = 0; i < Object.keys(boxData.boxClassList).length; i++) {
            let style = boxData.boxClassList[i];
            if (style != 'box' && style != 'box-input') {
                box.classList.add(style);
            }
        }
        boxContainer.addEventListener("mousedown", startDrag);
        boxContainer.addEventListener("click", handleBoxSelection);
        box.id = 'box' + boxData.boxId;
        box.style.padding = "0px 5px";
        box.setAttribute("type", "text");
        box.classList.add("box");
        box.classList.add("box-input");
        boxContainer.classList.add("box");
        canvas.appendChild(boxContainer);
        boxContainer.appendChild(box);
    }

    function showColorDropdown(event, target, targetAttr) {
        console.log(event);
        let x = event.x; // Get the clicked button
        createColorDropdown(x, target, targetAttr);
    }

    function createColorDropdown(x, target, targetAttr) {
        // create a color dropdown menu
        let dropdownContainer = document.getElementById("colorDropdownContainer");
        let colorRanges = [  // Color ranges by column
            ["#FFFFFF", "#CCCCCC", "#AAAAAA", "#888888", "#555555", "#333333", "#000000"], // Black
            ["#FF9999", "#FF6666", "#FF3333", "#FF0000", "#CC0000", "#990000", "#660000"], // Red
            ["#FFD699", "#FFB366", "#FF9933", "#FF7700", "#CC7700", "#995500", "#664400"], // Orange
            ["#FFFF99", "#FFFF66", "#FFFF33", "#FFFF00", "#CCCC00", "#999900", "#666600"], // Yellow
            ["#78fd78", "#45ff45", "#00ff00", "#00cc00", "#00a200", "#007200", "#003600"], // Green
            ["#9999FF", "#6666FF", "#3333FF", "#0000FF", "#0000CC", "#000099", "#000066"], // Blue
            ["#B488FF", "#8C66FF", "#6633FF", "#4900b8", "#330066", "#190033", "#000022"], // Indigo
            ["#D58AD5", "#B267B2", "#904390", "#661066", "#550055", "#440044", "#330033"], // Purple
            ["#ffd1d1", "#FFB4C1", "#ff7685", "#ff4a5c", "#FF3344", "#CC2233", "#992233"], // Pink
            ["#D2B48C", "#AE8E6E", "#8B7355", "#705239", "#4B331F", "#33231A", "#1A120C"], // Brown
        ];
        // Create a table element
        let table = document.createElement("table");
        // Create rows and cells
        for (let i = 0; i < 7; i++) {
            let row = document.createElement("tr");
            for (let j = 0; j < 10; j++) {
                let cell = document.createElement("td");
                let button = document.createElement("button");
                // Set button attributes
                let colorIndex = j % colorRanges.length;
                let color = colorRanges[colorIndex][i];
                button.style.backgroundColor = color;
                button.classList.add('colorButton');
                button.style.width = '30px';
                button.style.height = '30px';
                button.onclick = function () {
                    changeColor(this.style.backgroundColor, target, targetAttr);
                };
                // Append button to the cell, and cell to the row
                cell.appendChild(button);
                row.appendChild(cell);
            }
            table.appendChild(row);   // Append the row to the table
        }
        // Clear previous content and append the new table to the grid container
        dropdownContainer.innerHTML = "";
        dropdownContainer.appendChild(table);
        let labelRow = document.createElement("tr");
        let labelCell = document.createElement("td");
        labelCell.setAttribute("colspan", "10");
        let customLabel = document.createElement("div");
        customLabel.innerHTML = "Custom";
        customLabel.style.fontSize = "20px";
        labelCell.appendChild(customLabel);
        labelRow.appendChild(labelCell);
        table.appendChild(labelRow);
        let customColorsRow = document.createElement("tr");
        customColorsRow.classList.add("dropdown-color");
        for (let i = 0; i < 10; i++) {
            let cell = document.createElement("td");
            let button = document.createElement("button");
            // Set button attributes
            button.style.width = '30px';
            button.style.height = '30px';
            // If there's a custom color, use it; otherwise, set the button to white
            if (customColors[i] !== null) {
                button.style.backgroundColor = customColors[i];
                button.onclick = function (e) {
                    // Handle button click based on shift key
                    if (e.shiftKey) {
                        pickColor(i, target, targetAttr, x); // Call pickColor if shift key is pressed
                    } else {
                        changeColor(this.style.backgroundColor, target, targetAttr);
                    }
                };
            } else {
                button.style.backgroundColor = "#FFFFFF";
                button.classList.add('customColorButton');
                button.onclick = function () {
                    // If color is null, call pickColor function
                    pickColor(i, target, targetAttr); // Pass the index of the clicked button to pickColor
                };
            }
            // Append button to the cell, and cell to the row
            cell.appendChild(button);
            customColorsRow.appendChild(cell);
        }
        table.appendChild(customColorsRow);
        // Position the dropdown underneath the clicked button
        dropdownContainer.style.position = 'absolute';
        dropdownContainer.style.top = document.getElementById('top-bar').getBoundingClientRect().bottom - 10 + 'px';
        dropdownContainer.style.left = x - 333 + 'px'; // 333 is the width of the table
        console.log(table.style.width);
        dropdownContainer.classList.add("dropdown-color");
        table.classList.add("dropdown-color");

    }

    // Function to open color picker and update customColors array
    function pickColor(index, target, targetAttr, x) {
        let colorInput = document.createElement("input");
        colorInput.type = "color";
        // Add an input event listener to handle color selection
        colorInput.addEventListener("input", function () {
            // Update the customColors array with the chosen color
            customColors[index] = colorInput.value;
            createColorDropdown(x, target, targetAttr);
        });
        //  Open the color picker
        colorInput.click();
    }

    canvas.addEventListener('mousedown', startSelection);
    setUpCustomInputs();
    window.addEventListener("keydown", onKeypress);
    canvas.ondragover = handleDragOver;
    canvas.ondrop = handleDrop;

</script>
</body>

</html>